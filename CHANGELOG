# Changelog

All notable changes to UEServer will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).

## [Unreleased]

### Added - 2025-12-26

#### RPC Server (C++ Plugin)
- Created UE5 plugin structure in `rpc/`
  - `UEServer.uplugin` - Plugin descriptor with metadata
  - `UEServer.Build.cs` - Build configuration with dependencies (Sockets, Networking, Json, JsonUtilities)
  - `UEServer.h` - Public module header
  - `UEServerModule.cpp` - Module implementation with startup/shutdown lifecycle
  - `UEServerRPC.h` - RPC server interface
  - `UEServerRPC.cpp` - RPC server implementation

- Implemented TCP server with dynamic port allocation
  - Binds to `127.0.0.1:0` (OS assigns available port)
  - Writes `.ueserver/rpc.json` with runtime state (port, pid, started timestamp)
  - Cleans up `.ueserver/rpc.json` on shutdown
  - Runs in dedicated thread (`FRunnable` implementation)
  - Non-blocking client connection handling

- Implemented JSON RPC protocol
  - Request format: `{"id": "...", "op": "...", ...params}`
  - Response format: `{"id": "...", "op": "...", "ok": true/false, ...fields}`
  - Error handling for invalid JSON

- Implemented `ping` operation
  - Request: `{"id": "req-001", "op": "ping"}`
  - Response: `{"id": "req-001", "op": "ping", "ok": true, "version": "0.1.0"}`
  - Used for health checks and server discovery

#### Documentation
- Created `rpc/README.md`
  - Installation instructions (project plugin vs engine plugin)
  - Usage guide and RPC protocol documentation
  - Manual testing examples with netcat
  - Architecture diagram
  - Troubleshooting guide

- Created `TODO` file
  - Phase 1: RPC BRIDGE MVP task breakdown
  - Success criteria definition
  - Future phase planning

- Created `CHANGELOG` (this file)

- Created `TESTING.md`
  - Step-by-step manual testing guide
  - Automated test script for RPC server
  - Success criteria and common issues
  - Integration with UETRAIL test project

- Created `.gitignore`
  - Exclude `.ueserver/` runtime state directory
  - Standard Python and IDE exclusions

#### Testing Setup
- Installed UEServer plugin in UETRAIL project (`/home/lpm/REPO/UETRAIL`)
  - Copied plugin to `Plugins/UEServer/`
  - Enabled in `UETRAIL.uproject`
  - Ready for manual testing with UE5

### Technical Details

**Port Discovery Mechanism:**
- RPC server binds to port 0 for dynamic allocation
- OS assigns available port (no conflicts between multiple UE5 instances)
- Runtime state written to `.ueserver/rpc.json`:
  ```json
  {
    "port": 45231,
    "pid": 12345,
    "started": "2025-12-26T10:30:00Z"
  }
  ```
- Bridge CLI reads this file from CWD to discover server port
- Stale file detection via PID validation

**Security:**
- Server always binds to localhost (127.0.0.1) only
- No external network exposure
- Future: TLS and authentication support planned

**Compatibility:**
- Unreal Engine 5.3+
- Platforms: Windows, Linux, macOS

### Status

**Completed:**
- ‚úÖ UE5 plugin structure
- ‚úÖ TCP server with dynamic port allocation
- ‚úÖ JSON RPC protocol
- ‚úÖ Ping operation
- ‚úÖ Runtime state management (.ueserver/rpc.json)

### Added - 2025-12-26 (Session 2)

#### Bridge CLI (Python with mypy)
- Created Python bridge CLI structure in `bridge/`
  - `pyproject.toml` - Package configuration with setuptools, mypy, ruff
  - `ue_bridge/` package with clean module structure
  - Entry point: `ue-bridge` CLI command and `python -m ue_bridge`

- Implemented port discovery (`port_discovery.py`)
  - Reads `.ueserver/rpc.json` from current working directory
  - Validates JSON format and required fields (port, pid, started)
  - PID validation to detect stale port files (via `os.kill(pid, 0)`)
  - Clear error messages for all failure modes

- Implemented TCP client (`tcp_client.py`)
  - Async TCP connection using `asyncio.open_connection()`
  - Line-based JSON protocol (newline-delimited)
  - Request format: `{"id": "...", "op": "...", ...params}\n`
  - Response parsing with timeout and error handling
  - Connection cleanup (graceful close)

- Implemented tool system (`tools.py`)
  - Tool registry pattern (same as BlenderServer)
  - `ue.ping` tool for health checks
  - Extensible for future tools (UI inspection, control)

- Implemented CLI interface (`cli.py`)
  - CLI mode: `ue-bridge ue.ping`
  - Stdio mode: `echo '{"tool":"ue.ping","args":{}}' | ue-bridge`
  - Automatic port discovery on startup
  - Key=value argument parsing
  - Type auto-detection (bool, int, float, string)
  - Help text with examples

- Type safety
  - Full mypy type annotations throughout
  - Type protocols for extensibility (`ToolHandler`)
  - TypedDict for structured data (`ToolContext`, `PortDiscoveryResult`, etc.)
  - Passes `mypy --strict` with zero issues

- Documentation
  - `bridge/README.md` with usage examples
  - Inline docstrings for all public functions
  - Protocol reference documentation

- Development setup
  - `.gitignore` for Python artifacts
  - `mypy.ini` with strict type checking
  - `.python-version` (3.11)
  - `requirements.txt` and `requirements-dev.txt`

### Technical Details - Bridge CLI

**Architecture:**
```
CLI Invocation ‚Üí Port Discovery ‚Üí TCP Client ‚Üí UE RPC Server
```

**Port Discovery Flow:**
1. Read `.ueserver/rpc.json` from CWD
2. Validate JSON structure and types
3. Check if PID is alive (detect crashed server)
4. Return port or error message

**TCP Protocol:**
- Line-based JSON (newline-delimited)
- Request: `{"id": "cli-abc123", "op": "ping"}\n`
- Response: `{"id": "cli-abc123", "op": "ping", "ok": true, "version": "0.1.0"}\n`

**Error Handling:**
- Port file not found ‚Üí "UE RPC server not running"
- Invalid JSON ‚Üí "Invalid JSON in rpc.json"
- Stale PID ‚Üí "Stale port file detected"
- Connection refused ‚Üí "Cannot reach UE RPC"
- Timeout ‚Üí "Timeout contacting UE RPC"

### Status

**Completed:**
- ‚úÖ UE5 plugin structure
- ‚úÖ TCP server with dynamic port allocation
- ‚úÖ JSON RPC protocol
- ‚úÖ Ping operation
- ‚úÖ Runtime state management (.ueserver/rpc.json)
- ‚úÖ Python bridge CLI structure
- ‚úÖ Port discovery implementation
- ‚úÖ TCP client implementation
- ‚úÖ CLI tool (ue.ping)
- ‚úÖ Type checking (mypy)

### Added - 2025-12-26 (Session 3 - Phase 1 Complete!)

#### Port Discovery Update
- Updated port discovery to read from `~/.ueserver/switchboard.json` (global)
  - Changed from `.ueserver/rpc.json` in project directory
  - Supports multiple UE5 instances running simultaneously
  - Matches instance by project path
  - Fallback to single instance if only one running

#### Health Check Feature
- Added `ue.health` tool with 500ms timeout
  - Fast health check before longer operations
  - Prevents infinite retry loops when server down
  - Returns `{"ok": true, "status": "healthy"}` or error

#### Timeout Configuration
- Added `--timeout=MS` CLI parameter
  - Configurable timeout for all operations
  - Default: 2000ms (2 seconds)
  - Example: `ue-bridge ue.ping --timeout=5000`

#### Testing & Validation
- Compiled UEServer plugin for UETRAIL project
  - Symlinked plugin from `/home/lpm/REPO/UEServer/rpc` to UETRAIL
  - Built with UE 5.7.1 build system
  - Plugin loads successfully in editor

- End-to-end testing completed ‚úÖ
  - UE5 server starts on dynamic port (33051)
  - `~/.ueserver/switchboard.json` created with instance info
  - Raw TCP test: `echo '{"id":"test","op":"ping"}' | nc 127.0.0.1 33051` ‚úÖ
  - Bridge ping: `ue-bridge ue.ping` ‚úÖ
  - Bridge health: `ue-bridge ue.health` ‚úÖ
  - Custom timeout: `ue-bridge ue.ping --timeout=5000` ‚úÖ

#### Documentation
- Updated CLI help text with new features
- Updated port discovery documentation
- Created `doc/DONE` to track completed work

### Status - Phase 1: RPC BRIDGE MVP ‚úÖ

**All Success Criteria Met:**
1. ‚úÖ UE5 plugin starts TCP server on dynamic port
2. ‚úÖ `~/.ueserver/switchboard.json` is created with correct port info
3. ‚úÖ Bridge CLI can discover port and connect
4. ‚úÖ `ue-bridge ue.ping` returns successful response
5. ‚úÖ Error handling works (server down, stale files)
6. ‚úÖ `ue-bridge ue.health` provides fast health checks (500ms timeout)
7. ‚úÖ Custom timeout support with --timeout parameter

**Phase 1 Complete!** üéâ

### Added - 2025-12-26 (Session 4 - Phase 2 Complete!)

#### MCP Integration (mcp/)
- Created MCP server package `ue-mcp`
  - Package structure in `mcp/ue_mcp/`
  - `pyproject.toml` with MCP SDK dependency (>=0.9.0)
  - Entry point: `ue-mcp` command and `python -m ue_mcp`
  - Installable with `pip install -e mcp/`

- Implemented thin MCP wrapper (`server.py`)
  - Direct imports from `ue_bridge` (no subprocess overhead)
  - Zero business logic - pure transport layer
  - Auto-discovery of tools from bridge's `TOOL_HANDLERS` registry
  - MCP protocol wrapping: stdio ‚Üî MCP types

- MCP server features
  - `list_tools` handler - auto-discovers tools from bridge
  - `call_tool` handler - delegates to bridge handlers
  - Port discovery integration
  - Clean error handling with helpful hints
  - Graceful shutdown on SIGINT

- Fixed entry point bug
  - Added `main()` function to `__main__.py`
  - Matches `pyproject.toml` console script definition

- Type safety
  - Full mypy type checking enabled (strict mode)
  - Passes `mypy --strict` with zero issues
  - Type stubs for MCP SDK decorators configured

- Documentation
  - `mcp/README.md` with installation and usage
  - Claude Code integration instructions
  - Design principles documented (zero logic, zero duplication)
  - Troubleshooting guide

- Configuration
  - `.mcp.json` created for local MCP server registration
  - Ready for Claude Code integration
  ```json
  {
    "ue-server": {
      "command": "python",
      "args": ["-m", "ue_mcp"],
      "env": {}
    }
  }
  ```

### Technical Details - MCP Integration

**Architecture:**
```
Claude Code ‚Üí MCP Protocol ‚Üí ue-mcp ‚Üí bridge ‚Üí UE RPC
              [stdio]       [THIN]    [LOGIC]   [LOGIC]
```

**Design Principles:**
1. **Zero Logic** - All logic in bridge/RPC, not MCP layer
2. **Zero Duplication** - Direct import from bridge (no code copying)
3. **Auto-Discovery** - Tools automatically register from bridge
4. **Thin Transport** - Just MCP protocol wrapping, nothing more

**Tools Available:**
- `ue.ping` - Ping UE RPC server
- `ue.health` - Quick health check (500ms timeout)

### Status - Phase 2: MCP Integration ‚úÖ

**Success Criteria Met (4/5):**
1. ‚úÖ MCP server can be started and discovered by MCP clients
2. ‚úÖ ue.ping tool works via MCP (implementation verified)
3. ‚úÖ ue.health tool works via MCP (implementation verified)
4. ‚úÖ Error handling is robust
5. ‚è≥ Integration with Claude Code verified (requires UE5 running)

**Phase 2 Implementation Complete!** üéâ

### Added - 2025-12-26 (Session 5 - Live Testing & Auto-Cleanup)

#### Port Discovery Auto-Cleanup
- Implemented automatic cleanup of dead instances in switchboard.json
  - Filters out instances where PID is not running
  - Writes cleaned list back to switchboard (best-effort)
  - Prevents "multiple instance" errors from stale entries
  - Makes single-instance fallback work reliably

**Rationale:** Path matching with relative paths was unreliable. Auto-cleanup ensures
switchboard.json only contains live instances, making discovery robust.

#### Type Safety Fix
- Fixed mypy type error in `tools.py`
  - Added `typing.cast` for ToolContext override in health check
  - Bridge passes `mypy --strict` with zero errors

#### Live Testing Results
- Started UE5 with UEServer plugin (UETRAIL project)
- Verified switchboard auto-cleanup works
  - Initial state: 2 instances (1 dead, 1 alive)
  - After bridge call: 1 instance (dead removed automatically)
- Bridge CLI tests: ‚úÖ PASS
  - `ue-bridge ue.ping` from UETRAIL directory
  - `ue-bridge ue.health` with 500ms timeout
- MCP Server tests: ‚úÖ PASS
  - MCP server starts successfully
  - Lists 2 tools: ue.health, ue.ping
  - Ready for Claude Code integration

### Status - Phase 2: MCP Integration ‚úÖ (5/5 COMPLETE!)

**All Success Criteria Met:**
1. ‚úÖ MCP server can be started and discovered by MCP clients
2. ‚úÖ ue.ping tool works via MCP (live tested)
3. ‚úÖ ue.health tool works via MCP (live tested)
4. ‚úÖ Error handling is robust
5. ‚úÖ Integration verified with UE5 running

**Phase 2 FULLY Complete!** üéâ

### Added - 2025-12-27 (Session 6 - ue.start Tool & Pre-Phase 3 Testing)

#### Bridge CLI Enhancement
- **NEW TOOL: `ue.start`** - Automated UE5 startup
  - Auto-detects .uproject file from CWD
  - Auto-detects UnrealEditor path (default: `/home/lpm/PROD/UnrealEngine-5.7.1/Engine/Binaries/Linux/UnrealEditor`)
  - Launches UE5 in background (detached process)
  - Waits for switchboard registration (configurable timeout, default 30s)
  - Returns port/pid info when server is ready
  - Usage: `python3 -m ue_bridge ue.start [wait_timeout=45]`

- CLI enhancement for startup commands
  - Special handling for `ue.start` - bypasses port discovery
  - Other commands still require running UE instance

#### Testing & Verification
- **Full Infrastructure Test** ‚úÖ
  - RPC Server: Started UE5, verified switchboard registration
  - Bridge CLI: All 3 tools tested and working
    - `ue.start` ‚Üí UE5 launched successfully (port 36499, PID 43971)
    - `ue.ping` ‚Üí Connection verified
    - `ue.health` ‚Üí Health check passed
  - MCP Server: Auto-discovered all 3 tools
    - Tools: `ue.health`, `ue.ping`, `ue.start`
    - Ready for Claude Code integration via `~/.claude`

#### Installation
- Bridge and MCP packages installed in editable mode
  - `pip install -e bridge/`
  - `pip install -e mcp/`
  - All dependencies resolved

### Status - Pre-Phase 3 Infrastructure ‚úÖ

**All systems operational and tested:**
1. ‚úÖ RPC Server running and responsive
2. ‚úÖ Bridge CLI with 3 working tools
3. ‚úÖ MCP server auto-discovering tools
4. ‚úÖ Automated UE5 startup capability
5. ‚úÖ Ready to begin Phase 3 (UI Automation)

### Added - 2025-12-27 (Session 8 - Phase 3A Complete!)

#### Phase 3A: UI Discovery & Inspection - ue.ui.get_tree

**RPC Server (C++):**
- Implemented `ui.get_tree` operation in `UEServerRPC.cpp`
  - Traverses Slate widget hierarchy from all visible windows
  - Returns structured JSON tree with widget metadata
  - Widget properties: type (SWindow, SButton, etc.), visibility, enabled state, geometry (x, y, width, height), text content, children
  - Configurable `max_depth` parameter (default: 10) to control recursion
  - Thread-safe: dispatches to Game Thread via `AsyncTask(ENamedThreads::GameThread)`
  - Uses `TPromise`/`TFuture` for synchronous wait from RPC thread

- Added `SerializeWidget` helper function
  - Recursive widget serialization
  - Captures widget type via `GetTypeAsString()`
  - Extracts geometry via `GetCachedGeometry()`
  - Gets accessible text via `GetAccessibleText()`
  - Traverses children via `GetChildren()` and `GetChildAt()`

- Threading fix for Slate API access
  - Problem: `FSlateApplication::Get()` can only be called from Game/Slate threads
  - Solution: RPC thread dispatches UI query to Game Thread, waits for completion
  - Pattern: `AsyncTask` + `TPromise`/`TFuture` for cross-thread synchronization

**Bridge (Python):**
- Implemented `ue.ui.get_tree` tool in `tools.py`
  - Calls RPC `ui.get_tree` operation
  - Passes `max_depth` parameter
  - Returns widget hierarchy as JSON

**Design Philosophy:**
- **Zero Abstraction**: Returns RAW Slate terminology (SWindow, SOverlay, geometry, etc.)
- **AI-UX First**: AI reads UE docs ‚Üí understands our responses directly
- **Bridge not DSL**: ue-server is an accessibility layer to existing UE/Slate API, not a new language

**Testing:**
- ‚úÖ Tested with live UE5 Editor (UETRAIL project)
- ‚úÖ Returns 3 top-level windows (main editor + notification windows)
- ‚úÖ Widget tree depth configurable (tested with depth=1, depth=2)
- ‚úÖ Works via bridge CLI stdio (both REPO and PROD)
- ‚úÖ Thread-safe - no crashes with Slate API calls
- ‚úÖ MCP auto-discovers new tool (zero config changes needed)

**Example Response:**
```json
{
  "ok": true,
  "windows": [
    {
      "type": "SWindow",
      "visible": true,
      "enabled": true,
      "geometry": {"x": 384, "y": 296, "width": 1286, "height": 726},
      "text": "UETRAIL - Unreal Editor",
      "children": [...],
      "child_count": 1
    }
  ],
  "window_count": 3
}
```

### Status - Phase 3A Complete! ‚úÖ

**Success Criteria Met:**
1. ‚úÖ AI can query full UI hierarchy of UE Editor
2. ‚úÖ Returns Slate widget tree with native terminology
3. ‚úÖ Thread-safe Slate API access
4. ‚úÖ Configurable traversal depth
5. ‚úÖ Works via stdio (accessible to all AI tools)
6. ‚úÖ MCP integration automatic

### Added - 2025-12-27 (Session 8 continued - ue.switchboard)

#### Switchboard Visibility Tool

**Bridge (Python):**
- Implemented `ue.switchboard` tool in `tools.py`
  - Reads switchboard state from `~/.ueserver/switchboard.json`
  - Returns all running UE instances with metadata
  - Instance properties: pid, port, project, project_name, started, alive
  - Checks process alive status via `os.kill(pid, 0)`
  - No port discovery required (reads from file system)

**CLI Enhancement:**
- Added `ue.switchboard` to special cases in `cli.py`
  - Bypasses port discovery (tool doesn't need running UE)
  - Works alongside `ue.start` as pre-connection tool

**Purpose:**
- Makes port discovery transparent and debuggable
- AI can inspect switchboard state without bash commands
- Useful for multi-instance debugging
- Shows which UE instances are alive vs stale

**Testing:**
- ‚úÖ CLI mode: `ue-bridge ue.switchboard`
- ‚úÖ Stdio mode: `echo '{"tool":"ue.switchboard"}' | ue-bridge`
- ‚úÖ Shows 1 running instance (UETRAIL project, port 41319)
- ‚úÖ Alive status correctly detected
- ‚úÖ MCP auto-discovers tool

**Example Response:**
```json
{
  "ok": true,
  "switchboard_path": "/home/lpm/.ueserver/switchboard.json",
  "instances": [
    {
      "pid": 71305,
      "port": 41319,
      "project": "../../../../../REPO/UETRAIL/UETRAIL.uproject",
      "project_name": "UETRAIL",
      "started": "2025-12-27T12:37:51.526Z",
      "alive": true
    }
  ],
  "instance_count": 1
}
```

### Added - 2025-12-27 (Session 9 - Phase 3B: Widget Query)

#### Phase 3B: UI Inspection - ue.ui.get_widget

**RPC Server (C++):**
- Implemented `ui.get_widget` operation in `UEServerRPC.cpp`
  - Accepts `path` parameter with "/" separator (e.g., "SWindow/SOverlay/SButton")
  - Fuzzy matching via `Contains()` for widget type and accessible text
  - Traverses widget hierarchy depth-first
  - Returns widget properties with immediate children (depth=2)
  - Thread-safe: dispatches to Game Thread via `AsyncTask` + `TPromise`/`TFuture`
  - Clear error messages when widget not found

- Implemented `FindWidgetByPath()` helper method
  - Splits path by "/" into components
  - Searches top-level windows for first component match
  - Recursively traverses children for subsequent components
  - Matches widgets by type name OR accessible text (flexible)
  - Returns nullptr if path component not found

**Bridge (Python):**
- Implemented `ue.ui.get_widget` tool in `tools.py`
  - Validates required `path` parameter
  - Calls RPC `ui.get_widget` operation
  - Returns widget details or clear error message
  - Registered in `TOOL_HANDLERS` for auto-discovery

**Testing:**
- ‚úÖ Built plugin successfully in UETRAIL project
- ‚úÖ CLI mode: `ue-bridge ue.ui.get_widget path=SWindow` ‚úÖ
- ‚úÖ Stdio mode: `echo '{"tool":"ue.ui.get_widget","args":{"path":"SWindow"}}' | ue-bridge` ‚úÖ
- ‚úÖ Path traversal: `path=SWindow/SOverlay` finds nested widgets ‚úÖ
- ‚úÖ Error handling: Invalid paths return clear errors ‚úÖ
- ‚úÖ MCP auto-discovers tool (6 tools total) ‚úÖ

**Example Response (success):**
```json
{
  "ok": true,
  "path": "SWindow/SOverlay",
  "widget": {
    "type": "SOverlay",
    "visible": true,
    "enabled": true,
    "geometry": {"x": 384, "y": 296, "width": 1286, "height": 726},
    "children": [
      {"type": "SImage", "visible": true, ...},
      {"type": "SVerticalBox", "visible": true, ...}
    ],
    "child_count": 5
  }
}
```

**Example Response (not found):**
```json
{
  "ok": false,
  "path": "InvalidWidget",
  "error": "Widget not found: InvalidWidget"
}
```

### Status - Phase 3B Widget Query Complete! ‚úÖ

**Success Criteria Met:**
1. ‚úÖ AI can find specific widgets by path
2. ‚úÖ Path traversal with fuzzy matching works reliably
3. ‚úÖ Returns detailed widget properties
4. ‚úÖ Error handling is robust
5. ‚úÖ Works via CLI and stdio (MCP ready)
6. ‚úÖ Thread-safe Game Thread dispatch

### Next: Phase 3B Remaining - Widget Search & UI Control

**Next Tasks (Phase 3B):**
- Widget search (`ue.ui.find_widgets`) - Search by criteria
- UI control operations (`ue.ui.click`, `ue.ui.type`, `ue.ui.invoke`)
- Action simulation in Slate
- Safety and validation

**Future (Phase 3C):**
- High-level workflows (content browser, menus, viewport)
- Common editor operations

---

**Contributors**: TwistedBrain and Claude Sonnet 4.5
