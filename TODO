# UEServer TODO

## Phase 2: MCP Integration

**Goal:** Create a thin MCP adapter that wraps the bridge CLI, enabling Claude Code and other MCP clients to interact with UE5.

**Important:** We're now on git branch `mcp` - Phase 1 MVP is complete and stable on main.

### Architecture & Logic Distribution

```
Claude Code/MCP Client → (MCP protocol) → MCP Adapter → (stdio) → Bridge CLI → (TCP) → UE RPC Server
                                            [THIN]                   [LOGIC]              [LOGIC]
```

**Logic Distribution:**
- **MCP Adapter**: NO logic - pure transport layer (stdio ↔ MCP protocol)
- **Bridge CLI**: Main logic - port discovery, TCP communication, tool implementation
- **UE RPC Server**: UE-specific logic - UI inspection, control, state management

**Why:** This allows Bridge to be developed independently. MCP is just a protocol wrapper.

### MCP Adapter (Python with MCP SDK)

- [x] Create MCP server structure
  - Package structure: mcp/ue_mcp/
  - Setup MCP SDK dependencies
  - Server entrypoint

- [x] Implement thin bridge CLI wrapper
  - Direct import from bridge (not subprocess - simpler and more efficient)
  - Zero business logic in MCP layer
  - Direct passthrough to bridge handlers
  - Clean error handling

- [x] Define MCP tools (thin wrappers only)
  - Tool: ue.ping - Direct bridge import
  - Tool: ue.health - Direct bridge import
  - Auto-discovery from TOOL_HANDLERS registry
  - Bridge handles all logic, MCP just forwards

- [x] MCP server lifecycle
  - Initialize and start MCP server
  - Handle client connections via stdio
  - Graceful shutdown
  - Resource cleanup

- [x] Testing
  - Type checking with mypy (passes)
  - Tool registration verified
  - Package installation verified
  - Ready for integration testing with UE running

### Success Criteria

Phase 2 is complete when:
1. [x] MCP server can be started and discovered by MCP clients
2. [x] ue.ping tool works via MCP (implementation verified)
3. [x] ue.health tool works via MCP (implementation verified)
4. [x] Error handling is robust
5. [ ] Integration with Claude Code is verified (requires UE running)

**Note:** Items 1-4 complete. Item 5 requires UE5 running with UEServer plugin.
Use `.mcp.json` configuration to test with Claude Code when UE is available.

### Reference Implementation

See BlenderServer's MCP implementation at `/home/lpm/PROD/BlenderServer/mcp/` for:
- MCP SDK usage patterns (thin wrapper approach)
- Bridge CLI subprocess management (stdio forwarding)
- Tool definition structure (minimal, no logic)
- Error passthrough strategies

**Important:** BlenderServer in PROD is the working reference - REPO is for development.

### Development Strategy

1. **Develop in ~/REPO/UEServer** (git branch: `mcp`)
2. **Test thoroughly** with BlenderServer patterns
3. **Clone to ~/PROD/UEServer** when stable (like BlenderServer)
4. **Production updates** only when absolutely necessary

### Next Steps After Phase 2

Determined by needs and completed work (AI:DevOps methodology):
- Possible: UI Inspection (list widgets, get properties)
- Possible: UI Control (trigger actions, update properties)
- Possible: Additional bridge tools
- Emergent based on Phase 2 learnings
