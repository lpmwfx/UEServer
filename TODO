# UEServer TODO

## Phase 3: UI Automation

**Goal:** Enable AI-driven UI automation in Unreal Editor through structured UI inspection and control.

**Important:** We're now on git branch `MPC-automation-phase-3`. Phases 1 & 2 are complete and stable on main.

### Architecture

```
Claude Code ‚Üí MCP ‚Üí Bridge ‚Üí RPC Server ‚Üí UE Slate UI System
              [MCP]  [LOGIC]   [LOGIC]      [UI QUERIES/ACTIONS]
```

**Focus Areas:**
1. **UI Inspection** - Discover and query UI elements
2. **UI Control** - Trigger actions and modify state
3. **AI-Friendly Patterns** - Make UI discoverable and actionable for AI agents

### Phase 3A: UI Discovery & Inspection ‚úÖ COMPLETE

**Goal:** AI can "see" the UE Editor UI structure and query properties.

- [x] **RPC: UI Tree Inspection**
  - ‚úÖ Implemented `ue.ui.get_tree` operation
  - ‚úÖ Traverses Slate widget hierarchy from all visible windows
  - ‚úÖ Returns structured JSON tree with widget info:
    - Widget type (e.g., SWindow, SButton, SOverlay)
    - Visibility state (visible, enabled)
    - Position and size (geometry: x, y, width, height)
    - Text content (via GetAccessibleText())
    - Parent-child relationships (recursive children array)
  - ‚úÖ Thread-safe: dispatches to Game Thread via AsyncTask
  - ‚úÖ Configurable max_depth parameter (default: 10)

- [x] **Bridge: UI Inspection Tools**
  - ‚úÖ `ue.ui.get_tree` - Get full UI hierarchy
  - ‚úÖ Type-safe response handling
  - ‚úÖ Auto-discovered by MCP

- [x] **Testing: UI Inspection**
  - ‚úÖ Tested with live UE5 Editor (UETRAIL project)
  - ‚úÖ Returns 3 windows (main editor + notification windows)
  - ‚úÖ Widget tree depth configurable
  - ‚úÖ Thread-safe - no crashes
  - ‚úÖ Works via stdio (REPO and PROD)

**Switchboard Visibility** ‚úÖ COMPLETE

- [x] **Bridge: Switchboard Inspection**
  - ‚úÖ Implemented `ue.switchboard` tool
  - ‚úÖ Returns current switchboard state from `~/.ueserver/switchboard.json`
  - ‚úÖ Shows all running UE instances: pid, port, project, started time, alive status
  - ‚úÖ Makes port discovery transparent and debuggable
  - ‚úÖ Works via CLI and stdio
  - ‚úÖ No port discovery needed (reads from file system)
  - ‚úÖ Auto-discovered by MCP

### Phase 3B: UI Inspection - Widget Query ‚úÖ COMPLETE

- [x] **RPC: Widget Query by Path**
  - ‚úÖ Implemented `ue.ui.get_widget` operation
  - ‚úÖ Accepts widget path with "/" separator (e.g., "SWindow/SOverlay/SButton")
  - ‚úÖ Returns detailed widget properties with immediate children (depth=2)
  - ‚úÖ Fuzzy matching via Contains() for widget type and accessible text
  - ‚úÖ Thread-safe: dispatches to Game Thread via AsyncTask
  - ‚úÖ Clear error messages when widget not found

**Testing Results:**
- ‚úÖ CLI mode: `ue-bridge ue.ui.get_widget path=SWindow` works
- ‚úÖ Stdio mode: `echo '{"tool":"ue.ui.get_widget","args":{"path":"SWindow"}}' | ue-bridge` works
- ‚úÖ Path traversal: `path=SWindow/SOverlay` correctly finds nested widgets
- ‚úÖ Error handling: Invalid paths return clear error messages
- ‚úÖ MCP auto-discovers tool (6 tools total now)

### Phase 3B: Remaining UI Inspection Features

- [ ] **RPC: Widget Search**
  - Implement `ue.ui.find_widgets` operation
  - Search by:
    - Widget type
    - Text content
    - Visibility state
    - Custom properties
  - Return array of matching widgets with paths

### Phase 3B: UI Control & Actions

**Goal:** AI can interact with UI elements (click, type, etc.).

- [ ] **RPC: Widget Actions**
  - Implement `ue.ui.click` operation
    - Accept widget path
    - Simulate click event
    - Return success/failure

  - Implement `ue.ui.type` operation
    - Accept widget path and text
    - Set text field value
    - Return success/failure

  - Implement `ue.ui.invoke` operation
    - Generic action invocation
    - Support for menu items, buttons, etc.

- [ ] **Bridge: UI Control Tools**
  - `ue.ui.click` - Click a widget
  - `ue.ui.type` - Type into text field
  - `ue.ui.invoke` - Invoke action
  - Error handling for invalid targets

- [ ] **Safety & Validation**
  - Validate widget exists before action
  - Check widget is visible and enabled
  - Timeout handling for actions
  - Graceful failure modes

- [ ] **Testing: UI Control**
  - Test clicking menu items
  - Test typing in search boxes
  - Test invoking actions
  - Verify error handling

### Phase 3C: Common UI Workflows

**Goal:** High-level operations for common editor tasks.

- [ ] **Content Browser Operations**
  - `ue.content.navigate` - Navigate to folder
  - `ue.content.search` - Search for assets
  - `ue.content.create` - Create new asset
  - `ue.content.import` - Import file

- [ ] **Menu Operations**
  - `ue.menu.click` - Click menu item by path
  - `ue.menu.list` - List available menu items
  - `ue.menu.find` - Find menu item by name

- [ ] **Viewport Operations**
  - `ue.viewport.focus` - Focus on object
  - `ue.viewport.set_camera` - Set camera position
  - `ue.viewport.capture` - Capture screenshot

- [ ] **Testing: Workflows**
  - Test content browser navigation
  - Test menu interactions
  - Test viewport control
  - End-to-end workflow tests

### Success Criteria

Phase 3 is complete when:
1. [ ] AI can query full UI hierarchy of UE Editor
2. [ ] AI can find specific widgets by search criteria
3. [ ] AI can click buttons and menu items
4. [ ] AI can type into text fields
5. [ ] Common workflows (content browser, menus) work reliably
6. [ ] Error handling is robust for invalid operations
7. [ ] All operations work via MCP with UE running

### Design Principles

**AI-First Design:**
- Structured, machine-readable responses (JSON)
- Descriptive widget identifiers
- Clear parent-child relationships
- Search-friendly metadata

**Safety:**
- Read-only operations first (inspection)
- Validation before destructive actions
- Timeout protection
- Clear error messages

**Performance:**
- Incremental tree traversal
- Caching where appropriate
- Efficient widget lookups
- Minimal UI blocking

### Technical Notes

**Slate UI Access:**
- Use `FSlateApplication::Get()` to access UI
- Traverse widget hierarchy via `GetAllWidgets()`
- Widget introspection via RTTI and Slate APIs
- Event simulation via Slate's event system

**Widget Identification:**
- Use widget metadata when available
- Generate stable paths based on hierarchy
- Support for both path-based and search-based lookup

**JSON Schema:**
```json
// UI Tree Response
{
  "ok": true,
  "root": {
    "type": "SWindow",
    "id": "MainFrame",
    "children": [
      {
        "type": "SMenuBar",
        "id": "MenuBar",
        "children": [...]
      }
    ]
  }
}

// Widget Query Response
{
  "ok": true,
  "widget": {
    "type": "SButton",
    "path": "MainFrame/Toolbar/PlayButton",
    "visible": true,
    "enabled": true,
    "text": "Play",
    "bounds": {"x": 100, "y": 50, "width": 80, "height": 30}
  }
}
```

### Reference Implementation

See BlenderServer's UI automation (if available) for:
- UI tree traversal patterns
- Widget action patterns
- Error handling strategies
- MCP integration for UI ops

### Development Strategy

1. **Start with Inspection (Phase 3A)** - Read-only, safe
2. **Add Control (Phase 3B)** - Incremental, validated
3. **Build Workflows (Phase 3C)** - High-level, AI-friendly
4. **Iterate based on usage** - AI:DevOps methodology

### AI Multimodal UX (Critical Design Principle)

**VIGTIG:** AI-UX skal g√• BEGGE VEJE - AI kan b√•de kontrollere OG sanse.

**Nuv√¶rende Status (Kun Kontrol):**
- ‚úÖ AI ‚Üí UE: Send kommandoer via RPC (ping, ui.get_tree, ui.get_widget)
- ‚ùå UE ‚Üí AI: Ingen visuel feedback endnu

**Manglende: AI Sensing Capabilities**

#### 1. Viewport Screenshots/Captures
- [ ] **RPC: ue.viewport.capture operation**
  - Capture UE viewport til PNG/JPG
  - Return base64-encoded image eller filepath
  - AI f√•r multimodal feedback p√• sine handlinger
  - Use case: "Did that button I clicked work? Let me SEE the result"

#### 2. UI State Dumps (Bedre end ui.get_tree)
- [ ] **Evalu√©r om ui.get_tree er for grov**
  - Nuv√¶rende: Returnerer widget hierarchy med basic properties
  - Problem: M√•ske mangler detaljer AI har brug for?
  - L√∏sning: AI kan kode sine egne dump scripts (via executePython/Blueprint)

- [ ] **RPC: ue.execute_python eller ue.execute_blueprint**
  - Tillad AI at k√∏re custom Python/Blueprint code
  - AI genererer sine EGNE data-dumps pr√¶cis som den har brug for
  - M√∏nster fra BlenderServer: "AI koder sin egen data-dump"
  - Mere fleksibelt end forudbyggede dump operations

#### 3. Video Capture (Animation Verification)
- [ ] **RPC: ue.viewport.record operation**
  - Record viewport animation til MP4
  - AI kan verificere animationer og workflows
  - Use case: "Play this sequence and let me watch the result"

**Design Philosophy:**
- Forudbyggede operations (ui.get_tree) er **startpunkter**
- AI udvikler sine EGNE tools via script execution
- Multimodal feedback (screenshots, video) er **kritisk** for AI-UX
- Ikke afh√¶ngig af at vi bygger "den perfekte dump" - AI koder sin egen

**BlenderServer Reference:**
- Screenshot artifacts: `/tmp/blender-capture/codex_still.png`
- Video artifacts: `/tmp/blender-capture/codex_anim.mp4`
- AI bruger visuel feedback til at verificere resultater

### Scripting Layers (Design Decision Needed)

**Sp√∏rgsm√•l:** Hvor skal AI-scripting leve? Tre muligheder:

#### Option A: UE Engine Scripting (Native Execution)

**1. Python i UE5 (unreal.py):**
```python
# RPC Operation: ue.execute_python
{
  "op": "execute_python",
  "code": "import unreal; editor = unreal.EditorLevelLibrary(); ..."
}
```
- ‚úÖ Fuld UE Python API adgang (unreal module)
- ‚úÖ K√∏rer direkte i UE runtime
- ‚úÖ AI koder custom dumps/tools i Python
- ‚ö†Ô∏è Security: Arbitrary code execution (whitelist needed)
- üìù Pattern: Som BlenderServer's `executePython`

**2. Blueprint Execution:**
```json
# RPC Operation: ue.execute_blueprint
{
  "op": "execute_blueprint",
  "blueprint_path": "/Game/AI/CustomDump.uasset",
  "params": {"detail_level": "full"}
}
```
- ‚úÖ Native UE Blueprint system
- ‚úÖ Visual scripting famili√¶r for UE users
- ‚úÖ Type-safe, sandboxed
- ‚ùå AI skal generere Blueprint JSON (komplekst)

**3. Console Commands:**
```cpp
// RPC Operation: ue.execute_console
{
  "op": "execute_console",
  "command": "stat fps; r.ScreenPercentage 50"
}
```
- ‚úÖ Simple, UE-native commands
- ‚úÖ Debugging, performance tuning
- ‚ö†Ô∏è Limited til console command API

#### Option B: Bridge Scripting (Python Orchestration)

**Bridge-level Python scripts:**
```python
# bridge/ue_scripts/custom_ui_dump.py
async def dump_ui_with_screenshots(ctx):
    tree = await ue_ui_get_tree({}, ctx)
    screenshot = await ue_viewport_capture({}, ctx)
    # Combine results, custom processing
    return {"tree": tree, "visual": screenshot}

# Tool: ue.run_bridge_script
```
- ‚úÖ Type-safe Python med mypy
- ‚úÖ Kan komponere multiple RPC calls
- ‚úÖ Platform-agnostisk (virker med b√•de UE og Blender patterns)
- ‚úÖ Easy debugging (Python debugger)
- ‚ùå Ingen direkte UE API adgang (kun via RPC)

#### FUNDAMENTAL INDSIGT: "Ren BPY er gud"

**Fra BlenderServer erfaring:**
> "BlenderServer er et ultimativet scripting af-abstraktionssystem - alt andet er bare tilbeh√∏r - ren BPY er gud"

**Hvad dette betyder:**
- **KERNE**: `executePython` med fuld bpy API adgang
- **Tilbeh√∏r**: `addPrimitive`, `moveObject`, `listObjects` - convenience for at komme i gang
- **Real power**: AI koder sine EGNE operations via ren bpy
- **Zero abstraktion**: Direkte adgang til engine API, ingen mellemm√¶nd

**For UEServer:**
- **KERNE**: `ue.execute_python` med fuld `unreal` module adgang
- **Tilbeh√∏r**: `ui.get_tree`, `ui.get_widget` - starter hj√¶lp
- **Real power**: AI koder sine egne UI dumps, workflows, tools
- **Pattern**: Samme som BlenderServer - minimal abstraktion, maximal API adgang

**Prioritering:**
1. ‚≠ê **execute_python** - DETTE ER FUNDAMENTET
2. üì¶ Primitive operations - Kun til onboarding
3. üéØ AI l√¶rer selv resten via scripting

#### Option C: Hybrid (Begge Dele) ‚≠ê KORREKT ARKITEKTUR

**Kombiner styrker:**
1. **UE Python** - Engine-native operations, custom dumps
2. **Bridge Scripts** - High-level orchestration, workflows
3. **Whitelisting** - Sikkerhed p√• begge lag

**Architecture:**
```
AI ‚Üí Bridge ‚Üí ue.execute_python ‚Üí UE Python Runtime (unreal.py)
AI ‚Üí Bridge ‚Üí ue.run_bridge_script ‚Üí Bridge Python ‚Üí Multiple RPC calls
```

**Use Cases:**
- **Engine-native dumps**: `ue.execute_python` med unreal.py
- **Complex workflows**: `ue.run_bridge_script` orchestration
- **Quick commands**: `ue.execute_console`

**Security Model (fra BlenderServer):**
```python
# Whitelisted directories:
- /ue-scripts/     # Bridge scripts
- /bpy-scripts/    # UE Python scripts (project-specific)

# Environment variables:
UESERVER_ALLOW_EXEC=true   # Enable execute_python
UESERVER_SCRIPT_DIRS=/path/to/project/bpy-scripts
```

#### Implementation Checklist

- [ ] **Phase 1: UE Python Execution**
  - [ ] RPC: `execute_python` operation in UEServerRPC.cpp
  - [ ] Execute Python in UE Python interpreter context
  - [ ] Capture stdout, stderr, return value
  - [ ] Whitelist /bpy-scripts directories
  - [ ] Bridge: `ue.execute_python` tool

- [ ] **Phase 2: Bridge Scripting**
  - [ ] Create `/ue-scripts` directory structure
  - [ ] Bridge: `ue.run_bridge_script` tool
  - [ ] Load Python scripts from whitelisted paths
  - [ ] Async orchestration of RPC calls

- [ ] **Phase 3: Script Management**
  - [ ] `ue.save_script` - Save to whitelisted directory
  - [ ] `ue.load_script` - Load and execute
  - [ ] `ue.list_scripts` - List available scripts
  - [ ] Pattern: Exactly like BlenderServer

**BlenderServer Reference:**
```python
# tools.py har allerede dette pattern:
blender.executePython(code="import bpy; ...")
blender.loadScript(filepath="bpy-scripts/my_tool.py")
blender.saveScript(filepath="bpy-scripts/new_tool.py", content="...")
blender.listScripts()
```

### Harmonization with BlenderServer (Optional Enhancements)

**Goal:** Maintain consistency with BlenderServer reference architecture without rigid adherence.

**Completed:**
- ‚úÖ TOOL_METADATA structure added to bridge/ue_bridge/tools.py
- ‚úÖ MCP server.py updated to use TOOL_METADATA
- ‚úÖ Proper JSON schemas for all 6 tools
- ‚úÖ Required fields marked in schemas (e.g., path for ue.ui.get_widget)

**Optional Future Enhancements:**

#### Documentation System (Low Priority)
- [ ] **Add docs.py module** (inspired by BlenderServer)
  - Man pages for key concepts (e.g., "switchboard", "slate-ui", "project-setup")
  - How-to guides for common workflows (e.g., "start-ue-rpc", "query-ui-widgets")
  - Accessible via bridge CLI and MCP
  - TypedDict structures: ManPage, HowTo
  - Functions: get_manpage(), get_howto(), list_manpages(), list_howtos()

- [ ] **Add ue.help, ue.man, ue.howto tools**
  - ue.help - Overview of UEServer system
  - ue.man topic=<name> - Get manual page
  - ue.howto topic=<name> - Get how-to guide
  - Improves AI discoverability

#### Input Validation (Low Priority)
- [ ] **Add validators.py module** (if needed)
  - Reusable validation functions: require_string(), optional_string()
  - Vector validation: require_vec3(), optional_vec3() (for future geometry tools)
  - Use in tools.py to validate inputs before RPC calls
  - Reduces validation duplication

**Note:** These are OPTIONAL enhancements for better AI-UX. Core functionality is complete.

### Next Steps After Phase 3

Determined by AI agent needs:
- Advanced UI automation (drag-drop, complex workflows)
- Blueprint automation (visual scripting)
- Asset management operations
- Level editing automation
- Build and packaging automation
