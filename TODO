# UEServer TODO

## Phase 2: MCP Integration

**Goal:** Create a thin MCP adapter that wraps the bridge CLI, enabling Claude Code and other MCP clients to interact with UE5.

**Important:** We're now on git branch `mcp` - Phase 1 MVP is complete and stable on main.

### Architecture & Logic Distribution

```
Claude Code/MCP Client → (MCP protocol) → MCP Adapter → (stdio) → Bridge CLI → (TCP) → UE RPC Server
                                            [THIN]                   [LOGIC]              [LOGIC]
```

**Logic Distribution:**
- **MCP Adapter**: NO logic - pure transport layer (stdio ↔ MCP protocol)
- **Bridge CLI**: Main logic - port discovery, TCP communication, tool implementation
- **UE RPC Server**: UE-specific logic - UI inspection, control, state management

**Why:** This allows Bridge to be developed independently. MCP is just a protocol wrapper.

### MCP Adapter (Python with MCP SDK)

- [ ] Create MCP server structure
  - Package structure: mcp/ue_mcp/
  - Setup MCP SDK dependencies
  - Server entrypoint

- [ ] Implement thin bridge CLI wrapper
  - Spawn bridge CLI as subprocess (working directory = UE project)
  - Forward stdio communication (no parsing, no logic)
  - Simple error passthrough
  - Minimal logging (connection state only)

- [ ] Define MCP tools (thin wrappers only)
  - Tool: ue_ping - Maps to `ue-bridge ue.ping`
  - Tool: ue_health - Maps to `ue-bridge ue.health`
  - Direct stdio passthrough - no response parsing in MCP
  - Bridge handles all logic, MCP just forwards

- [ ] MCP server lifecycle
  - Initialize and start MCP server
  - Handle client connections
  - Graceful shutdown
  - Resource cleanup

- [ ] Testing
  - Test MCP server with MCP inspector
  - Test integration with Claude Code
  - Verify all tools work correctly
  - Test error cases

### Success Criteria

Phase 2 is complete when:
1. [ ] MCP server can be started and discovered by MCP clients
2. [ ] ue_ping tool works via MCP
3. [ ] ue_health tool works via MCP
4. [ ] Error handling is robust
5. [ ] Integration with Claude Code is verified

### Reference Implementation

See BlenderServer's MCP implementation at `/home/lpm/PROD/BlenderServer/mcp/` for:
- MCP SDK usage patterns (thin wrapper approach)
- Bridge CLI subprocess management (stdio forwarding)
- Tool definition structure (minimal, no logic)
- Error passthrough strategies

**Important:** BlenderServer in PROD is the working reference - REPO is for development.

### Development Strategy

1. **Develop in ~/REPO/UEServer** (git branch: `mcp`)
2. **Test thoroughly** with BlenderServer patterns
3. **Clone to ~/PROD/UEServer** when stable (like BlenderServer)
4. **Production updates** only when absolutely necessary

### Next Steps After Phase 2

Determined by needs and completed work (AI:DevOps methodology):
- Possible: UI Inspection (list widgets, get properties)
- Possible: UI Control (trigger actions, update properties)
- Possible: Additional bridge tools
- Emergent based on Phase 2 learnings
