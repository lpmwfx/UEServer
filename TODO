# UEServer TODO

## Phase 2: MCP Integration

**Goal:** Create an MCP adapter that wraps the bridge CLI, enabling Claude Code and other MCP clients to interact with UE5.

### Architecture
```
Claude Code/MCP Client → (MCP protocol) → MCP Adapter → (stdio) → Bridge CLI → (TCP) → UE RPC Server
```

### MCP Adapter (Python with MCP SDK)

- [ ] Create MCP server structure
  - Package structure: mcp/ue_mcp/
  - Setup MCP SDK dependencies
  - Server entrypoint

- [ ] Implement bridge CLI wrapper
  - Spawn bridge CLI as subprocess
  - Communicate via stdio
  - Parse JSON responses
  - Error handling and logging

- [ ] Define MCP tools
  - Tool: ue_ping - Ping UE server
  - Tool: ue_health - Health check
  - Map to bridge CLI commands

- [ ] MCP server lifecycle
  - Initialize and start MCP server
  - Handle client connections
  - Graceful shutdown
  - Resource cleanup

- [ ] Testing
  - Test MCP server with MCP inspector
  - Test integration with Claude Code
  - Verify all tools work correctly
  - Test error cases

### Success Criteria

Phase 2 is complete when:
1. [ ] MCP server can be started and discovered by MCP clients
2. [ ] ue_ping tool works via MCP
3. [ ] ue_health tool works via MCP
4. [ ] Error handling is robust
5. [ ] Integration with Claude Code is verified

### Reference Implementation

See BlenderServer's MCP implementation at `/home/lpm/REPO/BlenderServer/mcp/` for:
- MCP SDK usage patterns
- Bridge CLI subprocess management
- Tool definition structure
- Error handling strategies

### Next Steps After Phase 2

- Phase 3: UI Inspection (list widgets, get properties)
- Phase 4: UI Control (trigger actions, update properties)
- Phase 5: Advanced features (scripting, automation)
