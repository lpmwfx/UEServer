# UEServer TODO

## Phase 3: UI Automation

**Goal:** Enable AI-driven UI automation in Unreal Editor through structured UI inspection and control.

**Important:** We're now on git branch `MPC-automation-phase-3`. Phases 1 & 2 are complete and stable on main.

### Architecture

```
Claude Code → MCP → Bridge → RPC Server → UE Slate UI System
              [MCP]  [LOGIC]   [LOGIC]      [UI QUERIES/ACTIONS]
```

**Focus Areas:**
1. **UI Inspection** - Discover and query UI elements
2. **UI Control** - Trigger actions and modify state
3. **AI-Friendly Patterns** - Make UI discoverable and actionable for AI agents

### Phase 3A: UI Discovery & Inspection ✅ COMPLETE

**Goal:** AI can "see" the UE Editor UI structure and query properties.

- [x] **RPC: UI Tree Inspection**
  - ✅ Implemented `ue.ui.get_tree` operation
  - ✅ Traverses Slate widget hierarchy from all visible windows
  - ✅ Returns structured JSON tree with widget info:
    - Widget type (e.g., SWindow, SButton, SOverlay)
    - Visibility state (visible, enabled)
    - Position and size (geometry: x, y, width, height)
    - Text content (via GetAccessibleText())
    - Parent-child relationships (recursive children array)
  - ✅ Thread-safe: dispatches to Game Thread via AsyncTask
  - ✅ Configurable max_depth parameter (default: 10)

- [x] **Bridge: UI Inspection Tools**
  - ✅ `ue.ui.get_tree` - Get full UI hierarchy
  - ✅ Type-safe response handling
  - ✅ Auto-discovered by MCP

- [x] **Testing: UI Inspection**
  - ✅ Tested with live UE5 Editor (UETRAIL project)
  - ✅ Returns 3 windows (main editor + notification windows)
  - ✅ Widget tree depth configurable
  - ✅ Thread-safe - no crashes
  - ✅ Works via stdio (REPO and PROD)

**Switchboard Visibility** ✅ COMPLETE

- [x] **Bridge: Switchboard Inspection**
  - ✅ Implemented `ue.switchboard` tool
  - ✅ Returns current switchboard state from `~/.ueserver/switchboard.json`
  - ✅ Shows all running UE instances: pid, port, project, started time, alive status
  - ✅ Makes port discovery transparent and debuggable
  - ✅ Works via CLI and stdio
  - ✅ No port discovery needed (reads from file system)
  - ✅ Auto-discovered by MCP

### Phase 3B: Remaining UI Inspection Features

- [ ] **RPC: Widget Query by Path**
  - Implement `ue.ui.get_widget` operation
  - Accept widget path (e.g., "MainFrame/MenuBar/File")
  - Return detailed widget properties
  - Support for wildcard/fuzzy matching

- [ ] **RPC: Widget Search**
  - Implement `ue.ui.find_widgets` operation
  - Search by:
    - Widget type
    - Text content
    - Visibility state
    - Custom properties
  - Return array of matching widgets with paths

### Phase 3B: UI Control & Actions

**Goal:** AI can interact with UI elements (click, type, etc.).

- [ ] **RPC: Widget Actions**
  - Implement `ue.ui.click` operation
    - Accept widget path
    - Simulate click event
    - Return success/failure

  - Implement `ue.ui.type` operation
    - Accept widget path and text
    - Set text field value
    - Return success/failure

  - Implement `ue.ui.invoke` operation
    - Generic action invocation
    - Support for menu items, buttons, etc.

- [ ] **Bridge: UI Control Tools**
  - `ue.ui.click` - Click a widget
  - `ue.ui.type` - Type into text field
  - `ue.ui.invoke` - Invoke action
  - Error handling for invalid targets

- [ ] **Safety & Validation**
  - Validate widget exists before action
  - Check widget is visible and enabled
  - Timeout handling for actions
  - Graceful failure modes

- [ ] **Testing: UI Control**
  - Test clicking menu items
  - Test typing in search boxes
  - Test invoking actions
  - Verify error handling

### Phase 3C: Common UI Workflows

**Goal:** High-level operations for common editor tasks.

- [ ] **Content Browser Operations**
  - `ue.content.navigate` - Navigate to folder
  - `ue.content.search` - Search for assets
  - `ue.content.create` - Create new asset
  - `ue.content.import` - Import file

- [ ] **Menu Operations**
  - `ue.menu.click` - Click menu item by path
  - `ue.menu.list` - List available menu items
  - `ue.menu.find` - Find menu item by name

- [ ] **Viewport Operations**
  - `ue.viewport.focus` - Focus on object
  - `ue.viewport.set_camera` - Set camera position
  - `ue.viewport.capture` - Capture screenshot

- [ ] **Testing: Workflows**
  - Test content browser navigation
  - Test menu interactions
  - Test viewport control
  - End-to-end workflow tests

### Success Criteria

Phase 3 is complete when:
1. [ ] AI can query full UI hierarchy of UE Editor
2. [ ] AI can find specific widgets by search criteria
3. [ ] AI can click buttons and menu items
4. [ ] AI can type into text fields
5. [ ] Common workflows (content browser, menus) work reliably
6. [ ] Error handling is robust for invalid operations
7. [ ] All operations work via MCP with UE running

### Design Principles

**AI-First Design:**
- Structured, machine-readable responses (JSON)
- Descriptive widget identifiers
- Clear parent-child relationships
- Search-friendly metadata

**Safety:**
- Read-only operations first (inspection)
- Validation before destructive actions
- Timeout protection
- Clear error messages

**Performance:**
- Incremental tree traversal
- Caching where appropriate
- Efficient widget lookups
- Minimal UI blocking

### Technical Notes

**Slate UI Access:**
- Use `FSlateApplication::Get()` to access UI
- Traverse widget hierarchy via `GetAllWidgets()`
- Widget introspection via RTTI and Slate APIs
- Event simulation via Slate's event system

**Widget Identification:**
- Use widget metadata when available
- Generate stable paths based on hierarchy
- Support for both path-based and search-based lookup

**JSON Schema:**
```json
// UI Tree Response
{
  "ok": true,
  "root": {
    "type": "SWindow",
    "id": "MainFrame",
    "children": [
      {
        "type": "SMenuBar",
        "id": "MenuBar",
        "children": [...]
      }
    ]
  }
}

// Widget Query Response
{
  "ok": true,
  "widget": {
    "type": "SButton",
    "path": "MainFrame/Toolbar/PlayButton",
    "visible": true,
    "enabled": true,
    "text": "Play",
    "bounds": {"x": 100, "y": 50, "width": 80, "height": 30}
  }
}
```

### Reference Implementation

See BlenderServer's UI automation (if available) for:
- UI tree traversal patterns
- Widget action patterns
- Error handling strategies
- MCP integration for UI ops

### Development Strategy

1. **Start with Inspection (Phase 3A)** - Read-only, safe
2. **Add Control (Phase 3B)** - Incremental, validated
3. **Build Workflows (Phase 3C)** - High-level, AI-friendly
4. **Iterate based on usage** - AI:DevOps methodology

### Next Steps After Phase 3

Determined by AI agent needs:
- Advanced UI automation (drag-drop, complex workflows)
- Blueprint automation (visual scripting)
- Asset management operations
- Level editing automation
- Build and packaging automation
