# UEServer RAG Index

## Session 2-3 - Bridge CLI & Switchboard (2025-12-26)

### Web Documentation Searches

**Plugin Structure & Requirements:**
- [Plugins in UE 5.7](https://dev.epicgames.com/documentation/en-us/unreal-engine/plugins-in-unreal-engine)
- LoadingPhase options: Default, PreDefault
- Module Types: Runtime, RuntimeAndProgram, RuntimeNoCommandlet, etc.

**Key Finding:**
- Engine plugins need: `"Type": "RuntimeAndProgram"`, `"LoadingPhase": "PreDefault"`
- Location: `/UnrealEngine/Engine/Plugins/UEServer/`

### Switchboard Architecture

**Format:** `~/.ueserver/switchboard.json`
```json
{"instances":[{"pid":123,"port":41515,"project":"/path/to/proj.uproject","project_name":"Name","started":"2025-12-26T10:19:47Z"}]}
```

**RPC Changes:**
- RegisterInSwitchboard(), UnregisterFromSwitchboard()
- Uses FPlatformProcess::UserHomeDir() for ~/.ueserver

### Bridge CLI Files

- bridge/ue_bridge/{cli,types,port_discovery,tcp_client,tools}.py
- Install: `pip install -e bridge/`
- Usage: `python3 -m ue_bridge ue.ping`

### Status - Phase 1 Complete! üéâ

‚úÖ Bridge implementation complete
‚úÖ Switchboard code complete
‚úÖ Engine plugin loading (tested with UETRAIL)
‚úÖ End-to-end testing passed
‚úÖ Health check feature (500ms timeout)
‚úÖ Configurable timeout (--timeout parameter)

### Testing Results (Session 3)

**UE Server:**
- Port: 33051 (dynamic)
- File: ~/.ueserver/switchboard.json
- Raw TCP: `echo '{"id":"test","op":"ping"}' | nc 127.0.0.1 33051` ‚úÖ

**Bridge CLI:**
- `ue-bridge ue.ping` ‚úÖ
- `ue-bridge ue.health` ‚úÖ (500ms timeout)
- `ue-bridge ue.ping --timeout=5000` ‚úÖ

**Plugin Compilation:**
- Symlinked to UETRAIL/Plugins/UEServer
- Built with: `/Engine/Build/BatchFiles/Linux/Build.sh UETRAILEditor`
- Loads successfully in UE 5.7.1

### Links

- BlenderServer: `/home/lpm/REPO/BlenderServer/`
- UETRAIL: `/home/lpm/REPO/UETRAIL/`
- Engine: `/home/lpm/PROD/UnrealEngine-5.7.1/`

## Session 4 - MCP Integration (2025-12-26)

### MCP Server Implementation

**Package:** `ue-mcp` (mcp/ue_mcp/)
- Entry: `python -m ue_mcp` or `ue-mcp` command
- Install: `pip install -e mcp/`
- Dependencies: mcp>=0.9.0, ue-bridge (local)

**Architecture:**
```
Claude Code ‚Üí MCP Protocol ‚Üí ue-mcp ‚Üí bridge ‚Üí UE RPC
              [stdio]       [THIN]    [LOGIC]   [LOGIC]
```

### Key Design Decisions

**Direct Import vs Subprocess:**
- Initially considered spawning bridge as subprocess
- Implemented direct import instead (simpler, more efficient)
- Zero code duplication - imports from `ue_bridge.tools`
- Auto-discovery from `TOOL_HANDLERS` registry

**Zero Business Logic:**
- MCP layer only handles protocol translation
- All logic in bridge/RPC layers
- MCP just wraps: stdio ‚Üî MCP types ‚Üî bridge calls

### Implementation Files

- `mcp/ue_mcp/server.py` - Main MCP server (130 lines)
- `mcp/ue_mcp/__main__.py` - Entry point with main() function
- `mcp/ue_mcp/__init__.py` - Package marker
- `mcp/pyproject.toml` - Package config, mypy strict mode
- `mcp/requirements.txt` - MCP SDK + bridge dependency

### Configuration

**Local MCP Server (.mcp.json):**
```json
{
  "ue-server": {
    "command": "python",
    "args": ["-m", "ue_mcp"],
    "env": {}
  }
}
```

**Usage with Claude Code:**
- File must be in project root (for CWD context)
- MCP server uses CWD to find UE project for port discovery
- Tools: `ue.ping`, `ue.health`

### Testing & Verification

**Type Checking:**
- `mypy mcp/ue_mcp/` - PASSED ‚úÖ
- Strict mode enabled
- Zero type errors

**Package Installation:**
- `pip install -e mcp/` - SUCCESS ‚úÖ
- Bridge auto-installed via requirements.txt
- Console script `ue-mcp` registered

**Tool Registration:**
- `python -c "from ue_bridge.tools import TOOL_NAMES; print(TOOL_NAMES)"`
- Output: `['ue.health', 'ue.ping']` ‚úÖ

### Status - Phase 2 Complete! üéâ

**Completed (4/5 criteria):**
1. ‚úÖ MCP server starts and is discoverable
2. ‚úÖ ue.ping tool implemented
3. ‚úÖ ue.health tool implemented
4. ‚úÖ Error handling robust
5. ‚è≥ Claude Code integration (needs UE running)

**Ready for live testing** when UE5 + UEServer plugin is running.

### Next Steps

**Phase 3 (TBD):** UI Inspection/Control
- Widget hierarchy inspection
- Property reading/writing
- Action triggering
- Emergent based on usage needs

## Session 5 - Live Testing & Auto-Cleanup (2025-12-26)

### Problem Discovered

**Path Matching Issues:**
- Switchboard.json contains relative paths (e.g., `"../../../../../REPO/UETRAIL/UETRAIL.uproject"`)
- Path resolution failed when running from different directories
- Multiple stale instances caused "No matching UE instance found" errors

### Solution: Auto-Cleanup

**Implementation:** `bridge/ue_bridge/port_discovery.py`
- Added automatic cleanup before instance matching
- Filters instances to only keep alive PIDs
- Writes cleaned list back to switchboard.json (best-effort)
- Makes single-instance fallback work reliably

**Code added (lines 79-95):**
```python
# Auto-cleanup: Remove dead instances (PIDs not running)
alive_instances = []
for instance in instances:
    pid = instance.get("pid")
    if pid and isinstance(pid, int) and _is_process_running(pid):
        alive_instances.append(instance)

# If we removed any dead instances, write back cleaned switchboard
if len(alive_instances) < len(instances):
    try:
        data["instances"] = alive_instances
        with open(switchboard_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)
    except OSError:
        pass  # Cleanup is best-effort, continue even if write fails
```

### Live Testing Results

**Test Environment:**
- UE5.7.1 with UEServer plugin
- UETRAIL project at `/home/lpm/REPO/UETRAIL`
- Switchboard: `~/.ueserver/switchboard.json`

**Before Auto-Cleanup:**
- 2 instances in switchboard (1 dead PID, 1 alive)
- Bridge error: "No matching UE instance found"

**After Auto-Cleanup:**
- Bridge automatically cleaned dead instance
- Single live instance remained
- All tools work perfectly

**Tests Passed:**
1. ‚úÖ `ue-bridge ue.ping` - Returns `{"ok": true, "version": "0.1.0"}`
2. ‚úÖ `ue-bridge ue.health` - Returns `{"ok": true, "status": "healthy"}`
3. ‚úÖ `python -m ue_mcp` - Starts MCP server with 2 tools
4. ‚úÖ `mypy bridge/ue_bridge/` - Zero type errors (strict mode)

### Type Safety Fix

**File:** `bridge/ue_bridge/tools.py`
- Added `from typing import cast`
- Fixed line 39: `health_ctx = cast(ToolContext, {**ctx, "timeout_ms": 500})`
- Mypy now correctly recognizes ToolContext type

### Status: Phase 2 - 5/5 Complete! üéâ

**All Success Criteria Met:**
1. ‚úÖ MCP server discoverable
2. ‚úÖ ue.ping works via MCP
3. ‚úÖ ue.health works via MCP
4. ‚úÖ Error handling robust
5. ‚úÖ Integration verified with UE running

**System is production-ready for AI UI/UX automation!**

## Session 6 - ue.start Tool & Pre-Phase 3 Testing (2025-12-27)

### User Need: Automated UE5 Startup

**Problem:**
- Manual UE5 startup required before using bridge
- No way to start UE5 from CLI/MCP
- User asked: "kan ue-bridge ikke starte ue?" (can't ue-bridge start ue?)

### Solution: ue.start Tool

**Implementation:** `bridge/ue_bridge/tools.py`

**Features:**
- Auto-detects .uproject file from CWD
- Auto-detects UnrealEditor executable (default: `/home/lpm/PROD/UnrealEngine-5.7.1/Engine/Binaries/Linux/UnrealEditor`)
- Launches UE5 detached (background process with `start_new_session=True`)
- Polls switchboard.json for registration (configurable timeout, default 30s)
- Returns port/pid when ready

**CLI Enhancement:**
- Special handling for `ue.start` command (no port discovery needed)
- Modified `cli.py` to bypass `create_context()` for startup command
- Dummy context provided (won't be used by ue.start handler)

**Code Pattern:**
```python
async def ue_start(args: dict[str, Any], ctx: ToolContext) -> UEResponse:
    # Auto-detect paths
    project_path = args.get("project_path") or auto_detect_uproject()
    editor_path = args.get("editor_path") or "/home/lpm/PROD/UnrealEngine-5.7.1/..."

    # Launch detached
    subprocess.Popen([editor_path, project_path],
                     stdout=DEVNULL, stderr=DEVNULL,
                     start_new_session=True)

    # Wait for switchboard registration
    while time.time() - start < timeout:
        if switchboard_has_instances():
            return instance_info

    return timeout_error
```

### Testing Results

**Installation:**
- `pip install -e bridge/` ‚úÖ
- `pip install -e mcp/` ‚úÖ

**Bridge Tests:**
1. ‚úÖ `ue.start` - Launched UE5 successfully
   - Port: 36499
   - PID: 43971
   - Wait time: ~13 seconds

2. ‚úÖ `ue.ping` - Connection verified
   - Response: `{"ok": true, "version": "0.1.0"}`

3. ‚úÖ `ue.health` - Health check passed
   - Response: `{"ok": true, "status": "healthy"}`

**MCP Test:**
- ‚úÖ Server starts with 3 tools: `ue.health`, `ue.ping`, `ue.start`
- ‚úÖ Auto-discovery working
- ‚úÖ Ready for `~/.claude` integration

**Switchboard Verification:**
```json
{"instances":[{
  "pid":43971,
  "port":36499,
  "project":"../../../../../REPO/UETRAIL/UETRAIL.uproject",
  "project_name":"UETRAIL",
  "started":"2025-12-27T11:43:47.624Z"
}]}
```

### Key Findings

**UE5 Startup:**
- Editor path: `/home/lpm/PROD/UnrealEngine-5.7.1/Engine/Binaries/Linux/UnrealEditor`
- Test project: `/home/lpm/REPO/UETRAIL/UETRAIL.uproject`
- Startup time: ~13-15 seconds on this system
- Plugin auto-loads and registers in switchboard

**Process Management:**
- `start_new_session=True` properly detaches UE5 from bridge
- UE5 continues running after bridge exits
- Switchboard cleanup on UE5 exit still works

### Status: Pre-Phase 3 Complete ‚úÖ

**All Infrastructure Ready:**
1. ‚úÖ RPC Server running (tested)
2. ‚úÖ Bridge with 3 tools (ue.start, ue.ping, ue.health)
3. ‚úÖ MCP auto-discovering tools
4. ‚úÖ Automated startup capability
5. ‚úÖ Ready for Phase 3 (UI Automation)

**Next:** Begin Phase 3A - UI Inspection (Slate widget hierarchy traversal)

## Session 7 - MCP Global Configuration & Documentation (2025-12-27)

### Problem: Incorrect MCP Configuration Approach

**Initial Mistake:**
- Tried configuring MCP servers in project-specific `.mcp.json` files
- Created `.mcp.json` in ~/REPO/UEServer and ~/PROD/UEServer
- This caused blender and godot MCPs to fail when working in UEServer project

### Solution: Global MCP Configuration

**Correct Approach:**
- MCP servers are configured **globally in ~/.claude.json**
- Use `claude mcp add --transport stdio <name> --scope user -- <command>`
- NOT in project-specific .mcp.json files

**Implementation:**
```bash
# Add ue-server MCP globally
claude mcp add --transport stdio ue-server --scope user -- python -m ue_mcp

# Verify
claude mcp list
# Output:
# godot: ‚úì Connected
# blender: ‚úì Connected
# ue-server: ‚úì Connected
```

### MCP Configuration Scopes

**Three scopes available:**

1. **User Scope (Global)** - `~/.claude.json`
   - Available across ALL projects
   - Private to your user account
   - Use `--scope user` flag
   - **This is what we use for ue-server**

2. **Local Scope (Default)** - `~/.claude.json` (project-specific)
   - Only accessible in current project directory
   - Private to you

3. **Project Scope** - `.mcp.json` in project root
   - Checked into version control
   - Shared with team
   - Use `--scope project` flag

**Scope Hierarchy:**
1. Local (highest priority)
2. Project
3. User (lowest priority)

### Project Structure Cleanup

**Development vs Production:**
- **~/REPO/UEServer** - Development area (git repo)
- **~/PROD/UEServer** - Production area (git clone from REPO)
- Sync via: `git pull origin <branch>` in PROD

**Removed files:**
- `/home/lpm/REPO/UEServer/.mcp.json` (no longer needed)
- `/home/lpm/PROD/UEServer/.mcp.json` (no longer needed)
- `/home/lpm/REPO/UETRAIL/.mcp.json` (no longer needed)

### Documentation Downloaded

**Location:** `/home/lpm/DEVLIB/MANUALS/Claude-Code-MCP-Guide.md`

**Key Sections:**
- Installing MCP Servers (HTTP, SSE, Stdio)
- Managing MCP Servers
- MCP Installation Scopes
- Environment Variable Expansion
- OAuth 2.0 Authentication
- Enterprise MCP Configuration

### Key Learnings

**MCP Server Configuration:**
```bash
# Add stdio MCP server globally
claude mcp add --transport stdio <name> --scope user -- <command> [args...]

# The -- separator is critical:
# - Before --: Claude's flags (--env, --scope)
# - After --: Command to run

# Example with environment variable
claude mcp add --transport stdio server --scope user \
  --env API_KEY=value \
  -- python -m server_module
```

**Best Practice:**
- Use `--scope user` for personal tools (like ue-server)
- Use `--scope project` for team-shared tools
- Store sensitive data in environment variables with `--env`

### Status: MCP Configuration Complete ‚úÖ

**All systems operational:**
1. ‚úÖ ue-server MCP configured globally in ~/.claude
2. ‚úÖ All 3 MCP servers connected (godot, blender, ue-server)
3. ‚úÖ MCP documentation saved to ~/DEVLIB/MANUALS/
4. ‚úÖ Project cleanup complete (removed unnecessary .mcp.json files)
5. ‚úÖ Ready for Phase 3A implementation

## Session 8 - Phase 3A: UI Discovery & Inspection (2025-12-27)

### Implementation: ue.ui.get_tree

**Goal:** Enable AI to "see" UE Editor UI structure by querying Slate widget hierarchy.

**C++ RPC Server Changes:**

Files modified:
- `rpc/Source/UEServer/Private/UEServerRPC.cpp`
- `rpc/Source/UEServer/Public/UEServerRPC.h`

Added includes:
- `Framework/Application/SlateApplication.h`
- `Widgets/SWidget.h`
- `Widgets/SWindow.h`
- `Async/Async.h`

Implemented operations:
1. **HandleUIGetTree()**
   - Entry point for `ui.get_tree` RPC operation
   - Dispatches to Game Thread via `AsyncTask(ENamedThreads::GameThread)`
   - Uses `TPromise<FString>`/`TFuture<FString>` for cross-thread synchronization
   - RPC thread blocks waiting for Game Thread to complete UI query
   - Returns serialized JSON response

2. **SerializeWidget()**
   - Recursive helper for widget tree serialization
   - Captures: type (via `GetTypeAsString()`), visibility, enabled state, geometry, text, children
   - Respects `max_depth` parameter to limit recursion
   - Returns `TSharedPtr<FJsonObject>` with widget metadata

**Threading Challenge & Solution:**

Problem:
```
Assertion failed: IsInGameThread() || IsInSlateThread()
[File:Runtime/Slate/Public/Framework/Application/SlateApplication.h] [Line: 322]
```

Root cause: `FSlateApplication::Get()` can ONLY be called from Game Thread or Slate Thread.
RPC server runs in dedicated `FRunnable` thread.

Solution:
```cpp
// RPC thread creates Promise
TPromise<FString> Promise;
TFuture<FString> Future = Promise.GetFuture();

// Dispatch to Game Thread
AsyncTask(ENamedThreads::GameThread, [Promise]() mutable {
    // All Slate API calls happen here
    FSlateApplication::Get().GetAllVisibleWindowsOrdered(Windows);
    // ...serialize...
    Promise.SetValue(responseJson);
});

// RPC thread blocks waiting for result
return Future.Get();
```

This pattern ensures thread-safe Slate access while maintaining synchronous RPC behavior.

**Python Bridge Changes:**

File: `bridge/ue_bridge/tools.py`

Added tool:
```python
async def ue_ui_get_tree(args: dict[str, Any], ctx: ToolContext) -> UEResponse:
    """Get the Slate UI widget tree from Unreal Editor."""
    max_depth = args.get("max_depth", 10)
    return await call_ue("ui.get_tree", {"max_depth": max_depth}, ctx)
```

Tool registry:
```python
TOOL_HANDLERS = {
    ...
    "ue.ui.get_tree": ue_ui_get_tree,
}
```

**MCP Integration:**
- Zero changes required
- MCP server auto-discovers `ue.ui.get_tree` via `TOOL_HANDLERS` registry
- Works immediately after bridge update

### Design Philosophy Established

**Key Insight:** ue-server is NOT a new DSL - it's a BRIDGE to existing UE/Slate API.

Principles:
1. **Zero Abstraction in Data**
   - Return RAW Slate terminology: `SWindow`, `SOverlay`, `SNotificationList`
   - Native properties: `geometry`, `visible`, `enabled`, `children`
   - AI reads UE docs ‚Üí understands our responses directly

2. **AI-UX First**
   - Design for AI agents, not human brevity
   - Familiarity > conciseness
   - Consistency with UE ecosystem

3. **Abstraction Only for Convenience**
   - Like macros: shortcuts to common patterns
   - But RAW access always available
   - Example: `ue.ui.find_button("Play")` wraps `ue.ui.get_tree` + filter

4. **Bridge Naming Pattern**
   - Bridge tool: `ue.ui.get_tree`
   - RPC operation: `ui.get_tree`
   - Pattern: `ue.<domain>.<action>` ‚Üí `<domain>.<action>`

### Testing Results

**Environment:**
- UE 5.7.1
- UETRAIL test project
- Plugin symlinked from `/home/lpm/REPO/UEServer/rpc`

**Test Commands:**
```bash
# Via bridge CLI (REPO)
cd /home/lpm/REPO/UETRAIL
python3 -m ue_bridge ue.ui.get_tree max_depth=2

# Via bridge stdio (PROD)
cd /home/lpm/PROD/UEServer
echo '{"tool":"ue.ui.get_tree","args":{"max_depth":1}}' | python3 -m ue_bridge
```

**Results:**
- ‚úÖ Returns 3 top-level `SWindow` instances
- ‚úÖ Main editor window: "UETRAIL - Unreal Editor" (1286x726 pixels)
- ‚úÖ Notification windows detected
- ‚úÖ Widget tree depth configurable
- ‚úÖ No threading crashes
- ‚úÖ Thread-safe Slate API access verified

**Example Response:**
```json
{
  "tool": "ue.ui.get_tree",
  "ok": true,
  "response": {
    "op": "ui.get_tree",
    "ok": true,
    "windows": [
      {
        "type": "SWindow",
        "visible": true,
        "enabled": true,
        "geometry": {"x": 384, "y": 296, "width": 1286, "height": 726},
        "text": "UETRAIL - Unreal Editor",
        "children": [
          {
            "type": "SOverlay",
            "visible": true,
            "enabled": true,
            "geometry": {...},
            "children": [],
            "child_count": 0
          }
        ],
        "child_count": 1
      }
    ],
    "window_count": 3
  }
}
```

### Key Learnings

**Slate API Threading:**
- Slate is NOT thread-safe
- Must use `AsyncTask(ENamedThreads::GameThread)` for UI queries
- `TPromise`/`TFuture` pattern enables sync wait from other threads

**Widget Hierarchy:**
- Windows via `FSlateApplication::Get().GetAllVisibleWindowsOrdered()`
- Children via `widget->GetChildren()` and `GetChildAt(i)`
- Geometry via `widget->GetCachedGeometry()`
- Type via `widget->GetTypeAsString()` (returns class name like "SWindow")

**AI-First Design Works:**
- Zero abstraction = AI maps directly to UE documentation
- RAW Slate types in responses = no mental translation needed
- Tool names match UE operations = predictable patterns

### Status: Phase 3A Complete! ‚úÖ

**Success Criteria Met:**
1. ‚úÖ AI can query full UI hierarchy
2. ‚úÖ Returns native Slate terminology
3. ‚úÖ Thread-safe implementation
4. ‚úÖ Configurable traversal depth
5. ‚úÖ Stdio accessible (all AI tools can use)
6. ‚úÖ MCP auto-discovery

**Next:** Phase 3B/C - UI Control & Workflows
- Widget query by path
- Widget search by criteria
- UI actions (click, type, invoke)
